// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.21.0
// source: queries.sql

package db

import (
	"context"
	"net/netip"

	"github.com/jackc/pgx/v5/pgtype"
)

const getCrawlerSeedDomains = `-- name: GetCrawlerSeedDomains :many
SELECT domain
FROM instance
WHERE last_crawl_id IS NULL
  AND deleted_at IS NULL
UNION
(
  SELECT domain
  FROM instance
    JOIN crawl ON crawl.id = instance.last_crawl_id
  WHERE deleted_at IS NULL
  ORDER BY started_at ASC
)
LIMIT $1
`

// Get all domains that have not been crawled yet. If there are none, return the domains with the oldest crawl.
func (q *Queries) GetCrawlerSeedDomains(ctx context.Context, limit int32) ([]string, error) {
	rows, err := q.db.Query(ctx, getCrawlerSeedDomains, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var domain string
		if err := rows.Scan(&domain); err != nil {
			return nil, err
		}
		items = append(items, domain)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInstanceByDomain = `-- name: GetInstanceByDomain :one
SELECT id, domain, status, created_at, deleted_at, updated_at, software_name, last_crawl_id
FROM instance
WHERE domain = $1
LIMIT 1
`

func (q *Queries) GetInstanceByDomain(ctx context.Context, domain string) (Instance, error) {
	row := q.db.QueryRow(ctx, getInstanceByDomain, domain)
	var i Instance
	err := row.Scan(
		&i.ID,
		&i.Domain,
		&i.Status,
		&i.CreatedAt,
		&i.DeletedAt,
		&i.UpdatedAt,
		&i.SoftwareName,
		&i.LastCrawlID,
	)
	return i, err
}

const getInstanceWithLastCrawlByID = `-- name: GetInstanceWithLastCrawlByID :one
SELECT instance.id, domain, instance.status, created_at, deleted_at, updated_at, instance.software_name, last_crawl_id, crawl.id, instance_id, crawl.status, error_code, error_msg, started_at, finished_at, crawl.software_name, software_version, number_of_peers, open_registrations, total_users, active_half_year, active_month, local_posts, local_comments, raw_nodeinfo, addresses
FROM instance
  JOIN crawl ON crawl.id = instance.last_crawl_id
WHERE instance.id = $1
  AND instance.deleted_at IS NULL
LIMIT 1
`

type GetInstanceWithLastCrawlByIDRow struct {
	ID                pgtype.UUID
	Domain            string
	Status            InstanceStatus
	CreatedAt         pgtype.Timestamptz
	DeletedAt         pgtype.Timestamptz
	UpdatedAt         pgtype.Timestamptz
	SoftwareName      pgtype.Text
	LastCrawlID       pgtype.UUID
	ID_2              pgtype.UUID
	InstanceID        pgtype.UUID
	Status_2          CrawlStatus
	ErrorCode         NullCrawlErrorCode
	ErrorMsg          pgtype.Text
	StartedAt         pgtype.Timestamptz
	FinishedAt        pgtype.Timestamptz
	SoftwareName_2    pgtype.Text
	SoftwareVersion   pgtype.Text
	NumberOfPeers     pgtype.Int4
	OpenRegistrations pgtype.Bool
	TotalUsers        pgtype.Int4
	ActiveHalfYear    pgtype.Int4
	ActiveMonth       pgtype.Int4
	LocalPosts        pgtype.Int4
	LocalComments     pgtype.Int4
	RawNodeinfo       []byte
	Addresses         []netip.Addr
}

func (q *Queries) GetInstanceWithLastCrawlByID(ctx context.Context, id pgtype.UUID) (GetInstanceWithLastCrawlByIDRow, error) {
	row := q.db.QueryRow(ctx, getInstanceWithLastCrawlByID, id)
	var i GetInstanceWithLastCrawlByIDRow
	err := row.Scan(
		&i.ID,
		&i.Domain,
		&i.Status,
		&i.CreatedAt,
		&i.DeletedAt,
		&i.UpdatedAt,
		&i.SoftwareName,
		&i.LastCrawlID,
		&i.ID_2,
		&i.InstanceID,
		&i.Status_2,
		&i.ErrorCode,
		&i.ErrorMsg,
		&i.StartedAt,
		&i.FinishedAt,
		&i.SoftwareName_2,
		&i.SoftwareVersion,
		&i.NumberOfPeers,
		&i.OpenRegistrations,
		&i.TotalUsers,
		&i.ActiveHalfYear,
		&i.ActiveMonth,
		&i.LocalPosts,
		&i.LocalComments,
		&i.RawNodeinfo,
		&i.Addresses,
	)
	return i, err
}

const getPeersIDsByInstanceID = `-- name: GetPeersIDsByInstanceID :many
SELECT peer_id
FROM peering_relationship
  JOIN instance ON instance.id = peer_id
  AND instance.deleted_at IS NULL
WHERE instance_id = $1
`

func (q *Queries) GetPeersIDsByInstanceID(ctx context.Context, instanceID pgtype.UUID) ([]pgtype.UUID, error) {
	rows, err := q.db.Query(ctx, getPeersIDsByInstanceID, instanceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.UUID
	for rows.Next() {
		var peer_id pgtype.UUID
		if err := rows.Scan(&peer_id); err != nil {
			return nil, err
		}
		items = append(items, peer_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCrawlsPaginated = `-- name: ListCrawlsPaginated :many
SELECT id, instance_id, status, error_code, error_msg, started_at, finished_at, software_name, software_version, number_of_peers, open_registrations, total_users, active_half_year, active_month, local_posts, local_comments, raw_nodeinfo, addresses,
  COUNT(*) OVER() AS total_count
FROM crawl
WHERE instance_id = $1
ORDER BY started_at DESC
LIMIT $2 OFFSET $3
`

type ListCrawlsPaginatedParams struct {
	InstanceID pgtype.UUID
	Limit      int32
	Offset     int32
}

type ListCrawlsPaginatedRow struct {
	ID                pgtype.UUID
	InstanceID        pgtype.UUID
	Status            CrawlStatus
	ErrorCode         NullCrawlErrorCode
	ErrorMsg          pgtype.Text
	StartedAt         pgtype.Timestamptz
	FinishedAt        pgtype.Timestamptz
	SoftwareName      pgtype.Text
	SoftwareVersion   pgtype.Text
	NumberOfPeers     pgtype.Int4
	OpenRegistrations pgtype.Bool
	TotalUsers        pgtype.Int4
	ActiveHalfYear    pgtype.Int4
	ActiveMonth       pgtype.Int4
	LocalPosts        pgtype.Int4
	LocalComments     pgtype.Int4
	RawNodeinfo       []byte
	Addresses         []netip.Addr
	TotalCount        int64
}

func (q *Queries) ListCrawlsPaginated(ctx context.Context, arg ListCrawlsPaginatedParams) ([]ListCrawlsPaginatedRow, error) {
	rows, err := q.db.Query(ctx, listCrawlsPaginated, arg.InstanceID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCrawlsPaginatedRow
	for rows.Next() {
		var i ListCrawlsPaginatedRow
		if err := rows.Scan(
			&i.ID,
			&i.InstanceID,
			&i.Status,
			&i.ErrorCode,
			&i.ErrorMsg,
			&i.StartedAt,
			&i.FinishedAt,
			&i.SoftwareName,
			&i.SoftwareVersion,
			&i.NumberOfPeers,
			&i.OpenRegistrations,
			&i.TotalUsers,
			&i.ActiveHalfYear,
			&i.ActiveMonth,
			&i.LocalPosts,
			&i.LocalComments,
			&i.RawNodeinfo,
			&i.Addresses,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listErrorCodeDescriptions = `-- name: ListErrorCodeDescriptions :many
SELECT error_code, description
FROM crawl_errors
`

func (q *Queries) ListErrorCodeDescriptions(ctx context.Context) ([]CrawlError, error) {
	rows, err := q.db.Query(ctx, listErrorCodeDescriptions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CrawlError
	for rows.Next() {
		var i CrawlError
		if err := rows.Scan(&i.ErrorCode, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInstancesPaginated = `-- name: ListInstancesPaginated :many
SELECT instance.id, domain, instance.status, created_at, deleted_at, updated_at, instance.software_name, last_crawl_id, crawl.id, instance_id, crawl.status, error_code, error_msg, started_at, finished_at, crawl.software_name, software_version, number_of_peers, open_registrations, total_users, active_half_year, active_month, local_posts, local_comments, raw_nodeinfo, addresses,
  COUNT(*) OVER() AS total_count
FROM instance
  JOIN crawl ON crawl.id = instance.last_crawl_id
WHERE deleted_at IS NULL
  AND total_users > $3
ORDER BY total_users DESC
LIMIT $1 OFFSET $2
`

type ListInstancesPaginatedParams struct {
	Limit      int32
	Offset     int32
	TotalUsers pgtype.Int4
}

type ListInstancesPaginatedRow struct {
	ID                pgtype.UUID
	Domain            string
	Status            InstanceStatus
	CreatedAt         pgtype.Timestamptz
	DeletedAt         pgtype.Timestamptz
	UpdatedAt         pgtype.Timestamptz
	SoftwareName      pgtype.Text
	LastCrawlID       pgtype.UUID
	ID_2              pgtype.UUID
	InstanceID        pgtype.UUID
	Status_2          CrawlStatus
	ErrorCode         NullCrawlErrorCode
	ErrorMsg          pgtype.Text
	StartedAt         pgtype.Timestamptz
	FinishedAt        pgtype.Timestamptz
	SoftwareName_2    pgtype.Text
	SoftwareVersion   pgtype.Text
	NumberOfPeers     pgtype.Int4
	OpenRegistrations pgtype.Bool
	TotalUsers        pgtype.Int4
	ActiveHalfYear    pgtype.Int4
	ActiveMonth       pgtype.Int4
	LocalPosts        pgtype.Int4
	LocalComments     pgtype.Int4
	RawNodeinfo       []byte
	Addresses         []netip.Addr
	TotalCount        int64
}

// TODO: these types of paginated queries are not efficient
//
//	we should use a cursor instead or a CTE
func (q *Queries) ListInstancesPaginated(ctx context.Context, arg ListInstancesPaginatedParams) ([]ListInstancesPaginatedRow, error) {
	rows, err := q.db.Query(ctx, listInstancesPaginated, arg.Limit, arg.Offset, arg.TotalUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListInstancesPaginatedRow
	for rows.Next() {
		var i ListInstancesPaginatedRow
		if err := rows.Scan(
			&i.ID,
			&i.Domain,
			&i.Status,
			&i.CreatedAt,
			&i.DeletedAt,
			&i.UpdatedAt,
			&i.SoftwareName,
			&i.LastCrawlID,
			&i.ID_2,
			&i.InstanceID,
			&i.Status_2,
			&i.ErrorCode,
			&i.ErrorMsg,
			&i.StartedAt,
			&i.FinishedAt,
			&i.SoftwareName_2,
			&i.SoftwareVersion,
			&i.NumberOfPeers,
			&i.OpenRegistrations,
			&i.TotalUsers,
			&i.ActiveHalfYear,
			&i.ActiveMonth,
			&i.LocalPosts,
			&i.LocalComments,
			&i.RawNodeinfo,
			&i.Addresses,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
