// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.1
// source: mutations.sql

package db

import (
	"context"
	"net/netip"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCrawl = `-- name: CreateCrawl :one
INSERT INTO crawl (
        instance_id,
        status,
        error_code,
        error_msg,
        started_at,
        finished_at,
        software_name,
        software_version,
        number_of_peers,
        open_registrations,
        total_users,
        active_half_year,
        active_month,
        local_posts,
        local_comments,
        raw_nodeinfo,
        addresses
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9,
        $10,
        $11,
        $12,
        $13,
        $14,
        $15,
        $16,
        $17
    )
RETURNING id, instance_id, status, error_code, error_msg, started_at, finished_at, software_name, software_version, number_of_peers, open_registrations, total_users, active_half_year, active_month, local_posts, local_comments, raw_nodeinfo, addresses
`

type CreateCrawlParams struct {
	InstanceID        pgtype.UUID
	Status            CrawlStatus
	ErrorCode         NullCrawlErrorCode
	ErrorMsg          pgtype.Text
	StartedAt         pgtype.Timestamptz
	FinishedAt        pgtype.Timestamptz
	SoftwareName      pgtype.Text
	SoftwareVersion   pgtype.Text
	NumberOfPeers     pgtype.Int4
	OpenRegistrations pgtype.Bool
	TotalUsers        pgtype.Int4
	ActiveHalfYear    pgtype.Int4
	ActiveMonth       pgtype.Int4
	LocalPosts        pgtype.Int4
	LocalComments     pgtype.Int4
	RawNodeinfo       []byte
	Addresses         []netip.Addr
}

func (q *Queries) CreateCrawl(ctx context.Context, arg CreateCrawlParams) (Crawl, error) {
	row := q.db.QueryRow(ctx, createCrawl,
		arg.InstanceID,
		arg.Status,
		arg.ErrorCode,
		arg.ErrorMsg,
		arg.StartedAt,
		arg.FinishedAt,
		arg.SoftwareName,
		arg.SoftwareVersion,
		arg.NumberOfPeers,
		arg.OpenRegistrations,
		arg.TotalUsers,
		arg.ActiveHalfYear,
		arg.ActiveMonth,
		arg.LocalPosts,
		arg.LocalComments,
		arg.RawNodeinfo,
		arg.Addresses,
	)
	var i Crawl
	err := row.Scan(
		&i.ID,
		&i.InstanceID,
		&i.Status,
		&i.ErrorCode,
		&i.ErrorMsg,
		&i.StartedAt,
		&i.FinishedAt,
		&i.SoftwareName,
		&i.SoftwareVersion,
		&i.NumberOfPeers,
		&i.OpenRegistrations,
		&i.TotalUsers,
		&i.ActiveHalfYear,
		&i.ActiveMonth,
		&i.LocalPosts,
		&i.LocalComments,
		&i.RawNodeinfo,
		&i.Addresses,
	)
	return i, err
}

const createInstance = `-- name: CreateInstance :one
INSERT INTO instance (domain, software_name)
VALUES ($1, $2)
RETURNING id, domain, status, created_at, deleted_at, updated_at, software_name, last_crawl_id
`

type CreateInstanceParams struct {
	Domain       string
	SoftwareName pgtype.Text
}

func (q *Queries) CreateInstance(ctx context.Context, arg CreateInstanceParams) (Instance, error) {
	row := q.db.QueryRow(ctx, createInstance, arg.Domain, arg.SoftwareName)
	var i Instance
	err := row.Scan(
		&i.ID,
		&i.Domain,
		&i.Status,
		&i.CreatedAt,
		&i.DeletedAt,
		&i.UpdatedAt,
		&i.SoftwareName,
		&i.LastCrawlID,
	)
	return i, err
}

const createInstancesFromDomainList = `-- name: CreateInstancesFromDomainList :exec
INSERT INTO instance (domain)
SELECT domain
FROM unnest($1::varchar(255) []) domain ON CONFLICT DO NOTHING
`

func (q *Queries) CreateInstancesFromDomainList(ctx context.Context, domains []string) error {
	_, err := q.db.Exec(ctx, createInstancesFromDomainList, domains)
	return err
}

const deleteInstanceByID = `-- name: DeleteInstanceByID :exec
DELETE FROM instance
WHERE id = $1
`

func (q *Queries) DeleteInstanceByID(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteInstanceByID, id)
	return err
}

const updateInstanceFromLastCrawl = `-- name: UpdateInstanceFromLastCrawl :exec
UPDATE instance
SET last_crawl_id = $2,
    status = $3,
    software_name = $4,
    updated_at = NOW()
WHERE id = $1
`

type UpdateInstanceFromLastCrawlParams struct {
	ID           pgtype.UUID
	LastCrawlID  pgtype.UUID
	Status       InstanceStatus
	SoftwareName pgtype.Text
}

func (q *Queries) UpdateInstanceFromLastCrawl(ctx context.Context, arg UpdateInstanceFromLastCrawlParams) error {
	_, err := q.db.Exec(ctx, updateInstanceFromLastCrawl,
		arg.ID,
		arg.LastCrawlID,
		arg.Status,
		arg.SoftwareName,
	)
	return err
}

const updatePeeringRelationships = `-- name: UpdatePeeringRelationships :exec
INSERT INTO peering_relationship (instance_id, peer_id)
SELECT $1,
    id
FROM instance
WHERE domain = ANY($2::varchar(255) []) ON CONFLICT DO NOTHING
`

type UpdatePeeringRelationshipsParams struct {
	InstanceID pgtype.UUID
	Domains    []string
}

func (q *Queries) UpdatePeeringRelationships(ctx context.Context, arg UpdatePeeringRelationshipsParams) error {
	_, err := q.db.Exec(ctx, updatePeeringRelationships, arg.InstanceID, arg.Domains)
	return err
}
