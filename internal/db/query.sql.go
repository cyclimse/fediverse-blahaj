// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.1
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCompletedCrawl = `-- name: CreateCompletedCrawl :one
INSERT INTO crawls (
    server_id,
    status,
    software_name,
    number_of_peers,
    open_registrations,
    total_users,
    active_half_year,
    active_month,
    local_posts,
    local_comments
  )
VALUES ($1, 'completed', $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, server_id, status, error_msg, started_at, software_name, number_of_peers, open_registrations, total_users, active_half_year, active_month, local_posts, local_comments
`

type CreateCompletedCrawlParams struct {
	ServerID          pgtype.UUID
	SoftwareName      pgtype.Text
	NumberOfPeers     pgtype.Int4
	OpenRegistrations pgtype.Bool
	TotalUsers        pgtype.Int4
	ActiveHalfYear    pgtype.Int4
	ActiveMonth       pgtype.Int4
	LocalPosts        pgtype.Int4
	LocalComments     pgtype.Int4
}

func (q *Queries) CreateCompletedCrawl(ctx context.Context, arg CreateCompletedCrawlParams) (Crawl, error) {
	row := q.db.QueryRow(ctx, createCompletedCrawl,
		arg.ServerID,
		arg.SoftwareName,
		arg.NumberOfPeers,
		arg.OpenRegistrations,
		arg.TotalUsers,
		arg.ActiveHalfYear,
		arg.ActiveMonth,
		arg.LocalPosts,
		arg.LocalComments,
	)
	var i Crawl
	err := row.Scan(
		&i.ID,
		&i.ServerID,
		&i.Status,
		&i.ErrorMsg,
		&i.StartedAt,
		&i.SoftwareName,
		&i.NumberOfPeers,
		&i.OpenRegistrations,
		&i.TotalUsers,
		&i.ActiveHalfYear,
		&i.ActiveMonth,
		&i.LocalPosts,
		&i.LocalComments,
	)
	return i, err
}

const createFailedCrawl = `-- name: CreateFailedCrawl :one
INSERT INTO crawls (server_id, status, error_msg)
VALUES ($1, $2, $3)
RETURNING id, server_id, status, error_msg, started_at, software_name, number_of_peers, open_registrations, total_users, active_half_year, active_month, local_posts, local_comments
`

type CreateFailedCrawlParams struct {
	ServerID pgtype.UUID
	Status   CrawlStatus
	ErrorMsg pgtype.Text
}

func (q *Queries) CreateFailedCrawl(ctx context.Context, arg CreateFailedCrawlParams) (Crawl, error) {
	row := q.db.QueryRow(ctx, createFailedCrawl, arg.ServerID, arg.Status, arg.ErrorMsg)
	var i Crawl
	err := row.Scan(
		&i.ID,
		&i.ServerID,
		&i.Status,
		&i.ErrorMsg,
		&i.StartedAt,
		&i.SoftwareName,
		&i.NumberOfPeers,
		&i.OpenRegistrations,
		&i.TotalUsers,
		&i.ActiveHalfYear,
		&i.ActiveMonth,
		&i.LocalPosts,
		&i.LocalComments,
	)
	return i, err
}

const createServer = `-- name: CreateServer :one
INSERT INTO servers (domain, software_name)
VALUES ($1, $2)
RETURNING id, domain, status, created_at, deleted_at, updated_at, software_name, last_crawl_id
`

type CreateServerParams struct {
	Domain       string
	SoftwareName pgtype.Text
}

func (q *Queries) CreateServer(ctx context.Context, arg CreateServerParams) (Server, error) {
	row := q.db.QueryRow(ctx, createServer, arg.Domain, arg.SoftwareName)
	var i Server
	err := row.Scan(
		&i.ID,
		&i.Domain,
		&i.Status,
		&i.CreatedAt,
		&i.DeletedAt,
		&i.UpdatedAt,
		&i.SoftwareName,
		&i.LastCrawlID,
	)
	return i, err
}

const createServersFromDomainList = `-- name: CreateServersFromDomainList :exec
INSERT INTO servers (domain)
SELECT domain
FROM unnest($1::varchar(255) []) domain ON CONFLICT DO NOTHING
`

func (q *Queries) CreateServersFromDomainList(ctx context.Context, domains []string) error {
	_, err := q.db.Exec(ctx, createServersFromDomainList, domains)
	return err
}

const deleteServerByID = `-- name: DeleteServerByID :exec
DELETE FROM servers
WHERE id = $1
`

func (q *Queries) DeleteServerByID(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteServerByID, id)
	return err
}

const getServerWithLastCrawlByID = `-- name: GetServerWithLastCrawlByID :one
SELECT servers.id, domain, servers.status, created_at, deleted_at, updated_at, servers.software_name, last_crawl_id, crawls.id, server_id, crawls.status, error_msg, started_at, crawls.software_name, number_of_peers, open_registrations, total_users, active_half_year, active_month, local_posts, local_comments
FROM servers
  JOIN crawls ON crawls.id = servers.last_crawl_id
WHERE servers.id = $1
  AND servers.deleted_at IS NULL
LIMIT 1
`

type GetServerWithLastCrawlByIDRow struct {
	ID                pgtype.UUID
	Domain            string
	Status            ServerStatus
	CreatedAt         pgtype.Timestamptz
	DeletedAt         pgtype.Timestamptz
	UpdatedAt         pgtype.Timestamptz
	SoftwareName      pgtype.Text
	LastCrawlID       pgtype.UUID
	ID_2              pgtype.UUID
	ServerID          pgtype.UUID
	Status_2          CrawlStatus
	ErrorMsg          pgtype.Text
	StartedAt         pgtype.Timestamptz
	SoftwareName_2    pgtype.Text
	NumberOfPeers     pgtype.Int4
	OpenRegistrations pgtype.Bool
	TotalUsers        pgtype.Int4
	ActiveHalfYear    pgtype.Int4
	ActiveMonth       pgtype.Int4
	LocalPosts        pgtype.Int4
	LocalComments     pgtype.Int4
}

func (q *Queries) GetServerWithLastCrawlByID(ctx context.Context, id pgtype.UUID) (GetServerWithLastCrawlByIDRow, error) {
	row := q.db.QueryRow(ctx, getServerWithLastCrawlByID, id)
	var i GetServerWithLastCrawlByIDRow
	err := row.Scan(
		&i.ID,
		&i.Domain,
		&i.Status,
		&i.CreatedAt,
		&i.DeletedAt,
		&i.UpdatedAt,
		&i.SoftwareName,
		&i.LastCrawlID,
		&i.ID_2,
		&i.ServerID,
		&i.Status_2,
		&i.ErrorMsg,
		&i.StartedAt,
		&i.SoftwareName_2,
		&i.NumberOfPeers,
		&i.OpenRegistrations,
		&i.TotalUsers,
		&i.ActiveHalfYear,
		&i.ActiveMonth,
		&i.LocalPosts,
		&i.LocalComments,
	)
	return i, err
}

const getSeverByDomain = `-- name: GetSeverByDomain :one
SELECT id, domain, status, created_at, deleted_at, updated_at, software_name, last_crawl_id
FROM servers
WHERE domain = $1
LIMIT 1
`

func (q *Queries) GetSeverByDomain(ctx context.Context, domain string) (Server, error) {
	row := q.db.QueryRow(ctx, getSeverByDomain, domain)
	var i Server
	err := row.Scan(
		&i.ID,
		&i.Domain,
		&i.Status,
		&i.CreatedAt,
		&i.DeletedAt,
		&i.UpdatedAt,
		&i.SoftwareName,
		&i.LastCrawlID,
	)
	return i, err
}

const listServersPaginated = `-- name: ListServersPaginated :many
SELECT servers.id, domain, servers.status, created_at, deleted_at, updated_at, servers.software_name, last_crawl_id, crawls.id, server_id, crawls.status, error_msg, started_at, crawls.software_name, number_of_peers, open_registrations, total_users, active_half_year, active_month, local_posts, local_comments,
  COUNT(*) OVER() AS total_count
FROM servers
  JOIN crawls ON crawls.id = servers.last_crawl_id
WHERE deleted_at IS NULL
  AND total_users > $3
ORDER BY total_users DESC
LIMIT $1 OFFSET $2
`

type ListServersPaginatedParams struct {
	Limit      int32
	Offset     int32
	TotalUsers pgtype.Int4
}

type ListServersPaginatedRow struct {
	ID                pgtype.UUID
	Domain            string
	Status            ServerStatus
	CreatedAt         pgtype.Timestamptz
	DeletedAt         pgtype.Timestamptz
	UpdatedAt         pgtype.Timestamptz
	SoftwareName      pgtype.Text
	LastCrawlID       pgtype.UUID
	ID_2              pgtype.UUID
	ServerID          pgtype.UUID
	Status_2          CrawlStatus
	ErrorMsg          pgtype.Text
	StartedAt         pgtype.Timestamptz
	SoftwareName_2    pgtype.Text
	NumberOfPeers     pgtype.Int4
	OpenRegistrations pgtype.Bool
	TotalUsers        pgtype.Int4
	ActiveHalfYear    pgtype.Int4
	ActiveMonth       pgtype.Int4
	LocalPosts        pgtype.Int4
	LocalComments     pgtype.Int4
	TotalCount        int64
}

// TODO: these types of paginated queries are not efficient
//
//	we should use a cursor instead or a CTE
func (q *Queries) ListServersPaginated(ctx context.Context, arg ListServersPaginatedParams) ([]ListServersPaginatedRow, error) {
	rows, err := q.db.Query(ctx, listServersPaginated, arg.Limit, arg.Offset, arg.TotalUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListServersPaginatedRow
	for rows.Next() {
		var i ListServersPaginatedRow
		if err := rows.Scan(
			&i.ID,
			&i.Domain,
			&i.Status,
			&i.CreatedAt,
			&i.DeletedAt,
			&i.UpdatedAt,
			&i.SoftwareName,
			&i.LastCrawlID,
			&i.ID_2,
			&i.ServerID,
			&i.Status_2,
			&i.ErrorMsg,
			&i.StartedAt,
			&i.SoftwareName_2,
			&i.NumberOfPeers,
			&i.OpenRegistrations,
			&i.TotalUsers,
			&i.ActiveHalfYear,
			&i.ActiveMonth,
			&i.LocalPosts,
			&i.LocalComments,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePeeringRelationships = `-- name: UpdatePeeringRelationships :exec
INSERT INTO peering_relationships (server_id, peer_id)
SELECT $1,
  id
FROM servers
WHERE domain = ANY($2::varchar(255) []) ON CONFLICT DO NOTHING
`

type UpdatePeeringRelationshipsParams struct {
	ServerID pgtype.UUID
	Domains  []string
}

func (q *Queries) UpdatePeeringRelationships(ctx context.Context, arg UpdatePeeringRelationshipsParams) error {
	_, err := q.db.Exec(ctx, updatePeeringRelationships, arg.ServerID, arg.Domains)
	return err
}

const updateServerLastCrawlID = `-- name: UpdateServerLastCrawlID :exec
UPDATE servers
SET last_crawl_id = $1,
  status = $2,
  updated_at = NOW()
WHERE id = $3
`

type UpdateServerLastCrawlIDParams struct {
	LastCrawlID pgtype.UUID
	Status      ServerStatus
	ID          pgtype.UUID
}

func (q *Queries) UpdateServerLastCrawlID(ctx context.Context, arg UpdateServerLastCrawlIDParams) error {
	_, err := q.db.Exec(ctx, updateServerLastCrawlID, arg.LastCrawlID, arg.Status, arg.ID)
	return err
}
